From 4ba57b4085f02cff91a029919fa1dc4418584e2e Mon Sep 17 00:00:00 2001
From: Andreas Beckmann <anbe@debian.org>
Date: Mon, 22 Jul 2013 12:48:15 +0200
Subject: [PATCH] adjust for kernel 3.10 procfs interface changes

based on the archlinux patch (author unknown)
restored backward compatibility by wrapping all changes with
KERNEL_VERSION(3,10,0) checks

Bug-Debian: http://bugs.debian.org/717361
Origin: other, https://projects.archlinux.org/svntogit/packages.git/plain/trunk/nvidia-linux-3.10.patch?h=packages/nvidia-304xx&id=787962153c92600e8a6d0756f026e6c9a87e48f8
---
 nv-procfs.c |  313 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 313 insertions(+)

diff --git a/nv-procfs.c b/nv-procfs.c
index 0bb30a2..904c06c 100644
--- a/nv-procfs.c
+++ b/nv-procfs.c
@@ -60,6 +60,7 @@ static char nv_registry_keys[NV_MAX_REGISTRY_KEYS_LENGTH];
         __entry;                                          \
     })
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 #define NV_CREATE_PROC_FILE(name,parent,__read_proc,           \
     __write_proc,__fops,__data)                                \
    ({                                                          \
@@ -89,10 +90,30 @@ static char nv_registry_keys[NV_MAX_REGISTRY_KEYS_LENGTH];
         __entry = NV_CREATE_PROC_ENTRY(name, __mode, parent);  \
         __entry;                                               \
     })
+#else
+
+#define NV_PROC_RW (S_IFREG|S_IRUGO|S_IWUSR)
+#define NV_PROC_RO (S_IFREG|S_IRUGO)
+
+#define NV_CREATE_PROC_DIR(name,parent)                        \
+   ({                                                          \
+        struct proc_dir_entry *__entry;                        \
+        int __mode = (S_IFDIR | S_IRUGO | S_IXUGO);            \
+        __entry = proc_mkdir_mode(name, __mode, parent);       \
+        __entry;                                               \
+    })
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,9,255)
+static inline void *PDE_DATA(const struct inode *inode) {
+	return PDE(inode)->data;
+}
+#endif
+#endif
 
 #define NV_PROC_WRITE_BUFFER_SIZE   (64 * RM_PAGE_SIZE)
 
 static int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 nv_procfs_read_gpu_info(
     char  *page,
     char **start,
@@ -100,19 +121,34 @@ nv_procfs_read_gpu_info(
     int    count,
     int   *eof,
     void  *data
+#else
+nv_procfs_show_gpu_info(
+    struct seq_file *m,
+    void *v
+#endif
 )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     nv_state_t *nv = data;
+#else
+    nv_state_t *nv = m->private;
+#endif
     nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
     struct pci_dev *dev = nvl->dev;
     char *type, *fmt, tmpstr[NV_DEVICE_NAME_LENGTH];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     int len = 0, status;
+#else
+    int status;
+#endif
     NvU8 *uuid;
     NvU32 vbios_rev1, vbios_rev2, vbios_rev3, vbios_rev4, vbios_rev5;
     NvU32 fpga_rev1, fpga_rev2, fpga_rev3;
     nv_stack_t *sp = NULL;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     *eof = 1;
+#endif
 
     NV_KMEM_CACHE_ALLOC_STACK(sp);
     if (sp == NULL)
@@ -139,26 +175,43 @@ nv_procfs_read_gpu_info(
         }
     }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     len += sprintf(page+len, "Model: \t\t %s\n", tmpstr);
     len += sprintf(page+len, "IRQ:   \t\t %d\n", nv->interrupt_line);
+#else
+    seq_printf(m, "Model: \t\t %s\n", tmpstr);
+    seq_printf(m, "IRQ:   \t\t %d\n", nv->interrupt_line);
+#endif
 
     if (NV_IS_GVI_DEVICE(nv))
     {
         status = rm_gvi_get_firmware_version(sp, nv, &fpga_rev1, &fpga_rev2,
                                              &fpga_rev3);
         if (status != RM_OK)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             len += sprintf(page+len, "Firmware: \t ????.??.??\n");
+#else
+            seq_printf(m, "Firmware: \t ????.??.??\n");
+#endif
         else
         {
             fmt = "Firmware: \t %x.%x.%x\n";
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             len += sprintf(page+len, fmt, fpga_rev1, fpga_rev2, fpga_rev3);
+#else
+            seq_printf(m, fmt, fpga_rev1, fpga_rev2, fpga_rev3);
+#endif
         }
     }
     else
     {
         if (rm_get_gpu_uuid(sp, nv, &uuid, NULL) == RM_OK)
         {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             len += sprintf(page+len, "GPU UUID: \t %s\n", (char *)uuid);
+#else
+            seq_printf(m, "GPU UUID: \t %s\n", (char *)uuid);
+#endif
             os_free_mem(uuid);
         }
 
@@ -166,12 +219,20 @@ nv_procfs_read_gpu_info(
                     &vbios_rev3, &vbios_rev4,
                     &vbios_rev5) != RM_OK)
         {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             len += sprintf(page+len, "Video BIOS: \t ??.??.??.??.??\n");
+#else
+            seq_printf(m, "Video BIOS: \t ??.??.??.??.??\n");
+#endif
         }
         else
         {
             fmt = "Video BIOS: \t %02x.%02x.%02x.%02x.%02x\n";
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             len += sprintf(page+len, fmt, vbios_rev1, vbios_rev2, vbios_rev3,
+#else
+            seq_printf(m, fmt, vbios_rev1, vbios_rev2, vbios_rev3,
+#endif
                            vbios_rev4, vbios_rev5);
         }
     }
@@ -180,12 +241,23 @@ nv_procfs_read_gpu_info(
         type = "PCI-E";
     else
         type = "PCI";
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     len += sprintf(page+len, "Bus Type: \t %s\n", type);
 
     len += sprintf(page+len, "DMA Size: \t %d bits\n",
+#else
+    seq_printf(m, "Bus Type: \t %s\n", type);
+
+    seq_printf(m, "DMA Size: \t %d bits\n",
+#endif
      nv_count_bits(dev->dma_mask));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     len += sprintf(page+len, "DMA Mask: \t 0x%llx\n", dev->dma_mask);
     len += sprintf(page+len, "Bus Location: \t %04x:%02x.%02x.%x\n",
+#else
+    seq_printf(m, "DMA Mask: \t 0x%llx\n", dev->dma_mask);
+    seq_printf(m, "Bus Location: \t %04x:%02x.%02x.%x\n",
+#endif
                    nv->domain, nv->bus, nv->slot, PCI_FUNC(dev->devfn));
 #if defined(DEBUG)
     do
@@ -193,7 +265,11 @@ nv_procfs_read_gpu_info(
         int j;
         for (j = 0; j < NV_GPU_NUM_BARS; j++)
         {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
             len += sprintf(page+len, "BAR%u: \t\t 0x%llx (%lluMB)\n",
+#else
+            seq_printf(m, "BAR%u: \t\t 0x%llx (%lluMB)\n",
+#endif
                            j, nv->bars[j].address, (nv->bars[j].size >> 20));
         }
     } while (0);
@@ -201,10 +277,35 @@ nv_procfs_read_gpu_info(
 
     NV_KMEM_CACHE_FREE_STACK(sp);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     return len;
+#else
+    return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+static int
+nv_procfs_open_gpu_info(
+    struct inode *inode,
+    struct file *file
+)
+{
+    return single_open(file, nv_procfs_show_gpu_info, PDE_DATA(inode));
 }
 
+static const struct file_operations nv_procfs_gpu_info_fops = {
+    .owner   = THIS_MODULE,
+    .open    = nv_procfs_open_gpu_info,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
+#endif
+
 static int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 nv_procfs_read_version(
     char  *page,
     char **start,
@@ -212,8 +313,14 @@ nv_procfs_read_version(
     int    count,
     int   *eof,
     void  *data
+#else
+nv_procfs_show_version(
+    struct seq_file *m,
+    void *v
+#endif
 )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     int len = 0;
     *eof = 1;
 
@@ -221,8 +328,43 @@ nv_procfs_read_version(
     len += sprintf(page+len, "GCC version:  %s\n", NV_COMPILER);
 
     return len;
+#else
+    seq_printf(m, "NVRM version: %s\n", pNVRM_ID);
+    seq_printf(m, "GCC version:  %s\n", NV_COMPILER);
+
+    return 0;
+#endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+static int
+nv_procfs_open_version(
+    struct inode *inode,
+    struct file *file
+)
+{
+    return single_open(file, nv_procfs_show_version, NULL);
+}
+
+static const struct file_operations nv_procfs_version_fops = {
+    .owner   = THIS_MODULE,
+    .open    = nv_procfs_open_version,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+static int
+nv_procfs_show_registry(
+    struct seq_file *m,
+    void *v
+);
+#endif
+
 static int
 nv_procfs_open_registry(
     struct inode *inode,
@@ -233,7 +375,11 @@ nv_procfs_open_registry(
     nv_stack_t *sp = NULL;
 
     if (0 == (file->f_mode & FMODE_WRITE))
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         return 0;
+#else
+        return single_open(file, nv_procfs_show_registry, PDE_DATA(inode));
+#endif
 
     nvfp = nv_alloc_file_private();
     if (nvfp == NULL)
@@ -282,6 +428,12 @@ nv_procfs_close_registry(
     RM_STATUS rm_status;
     int rc = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+    if (0 == (file->f_mode & FMODE_WRITE))
+        return single_release(inode, file);
+#endif
+
     nvfp = NV_GET_FILE_PRIVATE(file);
     if (nvfp == NULL)
         return 0;
@@ -346,12 +498,15 @@ done:
     return rc;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static struct file_operations nv_procfs_registry_fops = {
     .open    = nv_procfs_open_registry,
     .release = nv_procfs_close_registry,
 };
+#endif
 
 static int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 nv_procfs_read_params(
     char  *page,
     char **start,
@@ -359,26 +514,73 @@ nv_procfs_read_params(
     int    count,
     int   *eof,
     void  *data
+#else
+nv_procfs_show_params(
+    struct seq_file *m,
+    void *v
+#endif
 )
 {
     unsigned int i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     int len = 0;
+#endif
     nv_parm_t *entry;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     *eof = 1;
+#endif
 
     for (i = 0; (entry = &nv_parms[i])->name != NULL; i++)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         len += sprintf(page+len, "%s: %u\n", entry->name, *entry->data);
+#else
+        seq_printf(m, "%s: %u\n", entry->name, *entry->data);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     len += sprintf(page+len, "RegistryDwords: \"%s\"\n",
+#else
+    seq_printf(m, "RegistryDwords: \"%s\"\n",
+#endif
                 (NVreg_RegistryDwords != NULL) ? NVreg_RegistryDwords : "");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     len += sprintf(page+len, "RmMsg: \"%s\"\n",
+#else
+    seq_printf(m, "RmMsg: \"%s\"\n",
+#endif
                 (NVreg_RmMsg != NULL) ? NVreg_RmMsg : "");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     return len;
+#else
+    return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+static int
+nv_procfs_open_params(
+    struct inode *inode,
+    struct file *file
+)
+{
+    return single_open(file, nv_procfs_show_params, NULL);
 }
 
+static const struct file_operations nv_procfs_params_fops = {
+    .owner   = THIS_MODULE,
+    .open    = nv_procfs_open_params,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
+#endif
+
+
 static int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 nv_procfs_read_registry(
     char  *page,
     char **start,
@@ -386,9 +588,18 @@ nv_procfs_read_registry(
     int    count,
     int   *eof,
     void  *data
+#else
+nv_procfs_show_registry(
+    struct seq_file *m,
+    void *v
+#endif
 )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     nv_state_t *nv = data;
+#else
+    nv_state_t *nv = m->private;
+#endif
     nv_linux_state_t *nvl = NULL;
     char *registry_keys;
 
@@ -397,16 +608,33 @@ nv_procfs_read_registry(
     registry_keys = ((nvl != NULL) ?
             nvl->registry_keys : nv_registry_keys);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     *eof = 1;
     return sprintf(page, "Binary: \"%s\"\n", registry_keys);
+#else
+    seq_printf(m, "Binary: \"%s\"\n", registry_keys);
+
+    return 0;
+#endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static int
+#else
+static ssize_t
+#endif
 nv_procfs_write_registry(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     struct file   *file,
     const char    *buffer,
     unsigned long  count,
     void          *data
+#else
+    struct file       *file,
+    const char __user *buffer,
+    size_t             count,
+    loff_t            *pos
+#endif
 )
 {
     int status = 0;
@@ -438,17 +666,37 @@ nv_procfs_write_registry(
     }
     else
     {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         nvfp->proc_data = data;
+#else
+        nvfp->proc_data = PDE_DATA(file->f_inode);
+#endif
         nvfp->off += count;
     }
 
 done:
     up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     return ((status < 0) ? status : (int)count);
+#else
+    return ((status < 0) ? status : count);
+#endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+static const struct file_operations nv_procfs_registry_fops = {
+    .open    = nv_procfs_open_registry,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .write   = nv_procfs_write_registry,
+    .release = nv_procfs_close_registry,
+};
+#endif
+
 static int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 nv_procfs_read_text_file(
     char  *page,
     char **start,
@@ -456,12 +704,43 @@ nv_procfs_read_text_file(
     int    count,
     int   *eof,
     void  *data
+#else
+nv_procfs_show_text_file(
+    struct seq_file *m,
+    void *v
+#endif
 )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     *eof = 1;
     return sprintf(page, "%s", (char *)data);
+#else
+    seq_printf(m, "%s", (char *)m->private);
+
+    return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#else
+static int
+nv_procfs_open_text_file(
+    struct inode *inode,
+    struct file *file
+)
+{
+    return single_open(file, nv_procfs_show_text_file, PDE_DATA(inode));
 }
 
+static const struct file_operations nv_procfs_text_fops = {
+    .owner   = THIS_MODULE,
+    .open    = nv_procfs_open_text_file,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
+#endif
+
 static void
 nv_procfs_add_text_file(
     struct proc_dir_entry *parent,
@@ -469,10 +748,15 @@ nv_procfs_add_text_file(
     const char *text
 )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     NV_CREATE_PROC_FILE(filename, parent,
             nv_procfs_read_text_file, NULL, NULL, (void *)text);
+#else
+    proc_create_data(filename, NV_PROC_RO, parent, &nv_procfs_text_fops, (void *)text);
+#endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 static void nv_procfs_unregister_all(struct proc_dir_entry *entry)
 {
     while (entry)
@@ -487,6 +771,7 @@ static void nv_procfs_unregister_all(struct proc_dir_entry *entry)
     }
 }
 #endif
+#endif
 
 void nv_procfs_add_warning(
     const char *filename,
@@ -513,11 +798,16 @@ int nv_register_procfs(void)
     if (!proc_nvidia)
         goto failed;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     entry = NV_CREATE_PROC_FILE("params", proc_nvidia,
         nv_procfs_read_params, NULL, NULL, NULL);
+#else
+    entry = proc_create("params", NV_PROC_RO, proc_nvidia, &nv_procfs_params_fops);
+#endif
     if (!entry)
         goto failed;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     /*
      * entry->proc_fops originally points to a constant
      * structure, so to add more methods for the
@@ -533,6 +823,9 @@ int nv_register_procfs(void)
         nv_procfs_read_registry,
         nv_procfs_write_registry,
         &nv_procfs_registry_fops, NULL);
+#else
+    entry = proc_create("registry", NV_PROC_RW, proc_nvidia, &nv_procfs_registry_fops);
+#endif
     if (!entry)
         goto failed;
 
@@ -553,8 +846,12 @@ int nv_register_procfs(void)
 
     nv_procfs_add_text_file(proc_nvidia_patches, "README", __README_patches);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     entry = NV_CREATE_PROC_FILE("version", proc_nvidia,
         nv_procfs_read_version, NULL, NULL, NULL);
+#else
+    entry = proc_create("version", NV_PROC_RO, proc_nvidia, &nv_procfs_version_fops);
+#endif
     if (!entry)
         goto failed;
 
@@ -571,15 +868,23 @@ int nv_register_procfs(void)
         if (!proc_nvidia_gpu)
             goto failed;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         entry = NV_CREATE_PROC_FILE("information", proc_nvidia_gpu,
             nv_procfs_read_gpu_info, NULL, NULL, nv);
+#else
+	entry = proc_create_data("information", NV_PROC_RO, proc_nvidia_gpu, &nv_procfs_gpu_info_fops, nv);
+#endif
         if (!entry)
             goto failed;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
         entry = NV_CREATE_PROC_FILE("registry", proc_nvidia_gpu,
             nv_procfs_read_registry,
             nv_procfs_write_registry,
             &nv_procfs_registry_fops, nv);
+#else
+	entry = proc_create_data("registry", NV_PROC_RW, proc_nvidia_gpu, &nv_procfs_registry_fops, nv);
+#endif
         if (!entry)
             goto failed;
     }
@@ -587,7 +892,11 @@ int nv_register_procfs(void)
     return 0;
 #if defined(CONFIG_PROC_FS)
 failed:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     nv_procfs_unregister_all(proc_nvidia);
+#else
+    remove_proc_subtree("nvidia", proc_nvidia);
+#endif
     return -1;
 #endif
 }
@@ -595,6 +904,10 @@ failed:
 void nv_unregister_procfs(void)
 {
 #if defined(CONFIG_PROC_FS)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
     nv_procfs_unregister_all(proc_nvidia);
+#else
+    remove_proc_subtree("nvidia", proc_nvidia);
+#endif
 #endif
 }
-- 
1.7.10.4

